// Generated by CoffeeScript 1.9.2
var TODO, basename, debug, dev, dirname, error, extname, fs, normalize, promise, ref, ref1, reporters, sep, sequence, shared, stacks, tester, warn;

ref = require('path'), normalize = ref.normalize, sep = ref.sep, extname = ref.extname, basename = ref.basename, dirname = ref.dirname;

ref1 = objective.logger, TODO = ref1.TODO, error = ref1.error, warn = ref1.warn;

debug = objective.logger.createDebug('dev');

fs = require('fs');

promise = require('when').promise;

sequence = require('when/sequence');

shared = require('./shared');

tester = require('./tester');

reporters = require('./reporters');

stacks = require('./stacks');

process.on('uncaughtException', function(e) {
  return console.log("Exception captured out of test: " + (e.toString()));
});

module.exports = dev = shared.dev = {
  $$name: 'dev',
  $$beforeEach: tester.$$beforeEach,
  testDir: 'test',
  sourceDir: 'lib',
  walkDepth: 3,
  walkWidth: 3,
  compileTo: void 0,
  reporter: 'default',
  showErrors: false,
  reporters: require('./reporters'),
  matchTest: [/_spec\.coffee$/, /_spec\.js$/],
  matchSource: [/\.coffee$/, /\.js$/],
  nodeSource: null,
  init: function(callback) {
    var errors, files, pipeline, waiting;
    try {
      reporters[dev.reporter].enable();
    } catch (_error) {
      TODO('reporter require relative to where?');
      require(dev.reporter);
    }
    pipeline = objective.pipeline;
    files = {};
    pipeline.on('files.recurse.found', function(data) {
      var i, j, len, len1, match, ref2, ref3, results, results1;
      if (data.path.match(new RegExp("^" + dev.testDir))) {
        ref2 = dev.matchTest;
        results = [];
        for (i = 0, len = ref2.length; i < len; i++) {
          match = ref2[i];
          if (data.path.match(match)) {
            files[data.path] = {
              type: 'test'
            };
            debug("objective-dev matched test '" + data.path + "'");
            results.push(data.watch = true);
          } else {
            results.push(void 0);
          }
        }
        return results;
      } else if (data.path.match(new RegExp("^" + dev.sourceDir))) {
        ref3 = dev.matchSource;
        results1 = [];
        for (j = 0, len1 = ref3.length; j < len1; j++) {
          match = ref3[j];
          if (data.path.match(match)) {
            files[data.path] = {
              type: 'src'
            };
            debug("objective-dev matched source '" + data.path + "'");
            results1.push(data.watch = true);
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }
    });
    waiting = [];
    pipeline.on('files.recurse.end', function(arg, next) {
      var file, path, type;
      path = arg.path;
      if (!path.match(new RegExp("^" + dev.testDir))) {
        return next();
      }
      objective.noRoot = true;
      return sequence((function() {
        var results;
        results = [];
        for (file in files) {
          type = files[file].type;
          if (type !== 'test') {
            continue;
          }
          results.push((function(file) {
            return function() {
              return promise(function(resolve, reject) {
                var e;
                debug('processing recurse queued objective', file);
                try {
                  debug('already running', objective.currentChild.config.filename);
                } catch (_error) {}
                try {
                  require(process.cwd() + sep + file);
                  if (objective.currentChild.config.filename === file) {
                    return waiting.push(resolve);
                  }
                } catch (_error) {
                  e = _error;
                  error(e.stack);
                  return resolve();
                }
              });
            };
          })(file));
        }
        return results;
      })()).then(function() {
        debug('done queued');
        return pipeline.emit('multiple.objectives.done', {}, function() {
          objective.noRoot = false;
          return next();
        });
      });
    });
    pipeline.on('objective.empty', function() {
      try {
        return waiting.pop()();
      } catch (_error) {}
    });
    pipeline.on('objective.not.promised', function() {
      try {
        return waiting.pop()();
      } catch (_error) {}
    });
    pipeline.on('objective.init.error', function() {
      try {
        return waiting.pop()();
      } catch (_error) {}
    });
    pipeline.on('objective.run.error', function() {
      try {
        return waiting.pop()();
      } catch (_error) {}
    });
    pipeline.on('dev.test.after.all', function() {
      try {
        return waiting.pop()();
      } catch (_error) {}
    });
    errors = 0;
    pipeline.on('files.recurse.changed', function(arg, next) {
      var base, compiled, destination, dir, e, ext, file, foundTest, i, len, mBase, mExt, path, runTest, testPath;
      path = arg.path;
      runTest = function(path) {
        debug("running test at '" + path + "'");
        if (objective.currentChild != null) {
          warn("skipping '" + path + "' while running '" + objective.currentChild.config.filename + "'");
          return next();
        }
        delete require.cache[process.cwd() + sep + path];
        require(process.cwd() + sep + path);
        return next();
      };
      if (path.match(new RegExp("^" + dev.testDir))) {
        runTest(path);
      }
      if (path.match(new RegExp("^" + dev.sourceDir))) {
        if (path.match(/\.coffee$/)) {
          if (dev.compileTo != null) {
            destination = path.replace(new RegExp("^" + dev.sourceDir), dev.compileTo);
            destination = destination.replace(/\.coffee$/, '.js');
            debug('start compiling coffee from %s to %s', path, destination);
            try {
              compiled = objective.coffee.compile(fs.readFileSync(path).toString(), {
                bare: true,
                filename: path
              });
              fs.writeFileSync(destination, compiled);
              if (errors > 0) {
                error('resolved');
                errors = 0;
              }
              debug('done compiling coffee from %s to %s', path, destination);
              TODO('multiple tests from uuids in sourcefile header');
              testPath = path.replace(new RegExp("^" + dev.sourceDir), dev.testDir);
              dir = dirname(testPath);
              base = basename(testPath, ext = extname(testPath));
              testPath = dir + sep + base + '_spec';
              files = fs.readdirSync(dir);
              for (i = 0, len = files.length; i < len; i++) {
                file = files[i];
                mExt = extname(file);
                mBase = basename(file, mExt);
                if (mBase === base + '_spec') {
                  if (['js', 'coffee'].indexOf(mExt >= 0)) {
                    foundTest = dir + sep + mBase + mExt;
                  }
                }
              }
              if (foundTest) {
                return runTest(foundTest);
              }
              warn('missing objective at ' + dir + sep + base + '_spec' + ext);
            } catch (_error) {
              e = _error;
              error(e.toString());
              errors++;
              return next();
            }
          }
        }
        return next();
      }
      return next();
    });
    pipeline.on('prompt.commands.register.ask', function(command) {
      command.create('createModule', {
        description: '(dev) Create new module in the current project.',
        run: require('./commands/create_module'),
        help: "\nUsage: dev.createModule " + dev.testDir + "/path/to/module_name [templateName]\n\nCreates the '" + dev.testDir + "' file and the corresponding '" + dev.sourceDir + "' file.\n\n    ie.\n\n        " + dev.testDir + "/path/to/module_name.js\n        " + dev.sourceDir + "/path/to/module_name.js\n\nThe paths match up so that when the '" + dev.sourceDir + "' file changes the\ncorresponding '" + dev.testDir + "' file can be found and run.\n\nIt is recommended to use underscores between the name parts\nso that the module injector can be used in tests.\n\n    ie.  \n\n        module_name.js will be injectable as ModuleName\n        (provided that it is unique project-wide)\n\nIf templateName is specified the corresponding template will be used.\n\n    ie.\n\n        ~/.objective/templates/dev/templateName_spec.js\n\n\nNOTE: The templates are only installed upon registration. (--register)\n",
        autoComplete: function(args, callback) {
          var directory, file, i, len, matches;
          if (args.length > 2) {
            return callback(null, null);
          }
          if (args.length === 1) {
            return callback(null, {
              type: 'path',
              startIn: normalize(dev.testDir + '/'),
              onlyDirectories: true
            });
          }
          if (args.length === 2) {
            try {
              directory = fs.readdirSync(process.env.HOME + '/.objective/templates/dev');
              matches = [];
              for (i = 0, len = directory.length; i < len; i++) {
                file = directory[i];
                if (file.match(new RegExp("_spec." + shared.language))) {
                  matches.push(file.replace("_spec." + shared.language, ''));
                }
              }
              return callback(null, matches);
            } catch (_error) {
              return callback(null, null);
            }
          }
        }
      });
      command.create('renameModule', {
        description: '(dev) Deletes module from the current project.',
        run: function(args, callback) {
          return callback();
        }
      });
      command.create('destroyModule', {
        description: '(dev) Deletes module from the current project.',
        run: function(args, callback) {
          return callback();
        }
      });
      command.create('testModule', {
        description: '(dev) Test a specific module.',
        run: function(args, callback) {
          return callback();
        }
      });
      return command.create('testAll', {
        description: '(dev) Test all modules.',
        run: function(args, callback) {
          return callback();
        }
      });
    });
    return callback();
  }
};
