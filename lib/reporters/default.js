// Generated by CoffeeScript 1.9.2
var EOL, TODO, colors, debug, error, firstfail, fs, info, logger, pipe, showAssertionError, showCode, walkStack;

logger = objective.logger, pipe = objective.pipe;

info = logger.info, error = logger.error, debug = logger.debug, TODO = logger.TODO;

colors = require('colors');

EOL = require('os').EOL;

TODO('Final stats after test (or test all)');

TODO('runs initiated by file changes may overlap, fix (perhaps {noOvertake} pipe on change watcher');

TODO('test timeouts error');

TODO('reporter calls null tests pending - actually bdd does it');

TODO('only walk from test onward, or ignore objective-dev');

fs = require('fs');

firstfail = false;

module.exports = function() {
  debug('using default test reporter');
  pipe.on('dev.test.before.all', function(payload) {
    return console.log();
  });
  pipe.on('dev.test.after.all', function(arg) {
    var duration, failed, failedMsg, fn, functions, j, k, len, len1, passed, passedMsg, pendMsg, pending, recurse, skipMsg, skipped, totalDuration, tree;
    tree = arg.tree, functions = arg.functions;
    for (j = 0, len = functions.length; j < len; j++) {
      fn = functions[j];
      if (fn.type !== 'test' && (fn.error != null)) {
        return;
      }
    }
    totalDuration = 0;
    for (k = 0, len1 = functions.length; k < len1; k++) {
      duration = functions[k].duration;
      if (duration != null) {
        totalDuration += duration;
      }
    }
    failed = 0;
    passed = 0;
    skipped = 0;
    pending = 0;
    recurse = function(node, skipping) {
      var child, l, len2, ref, results;
      if (skipping == null) {
        skipping = false;
      }
      if (node.type === 'it') {
        if (node.pending) {
          pending++;
        }
        if (node.skip || skipping || tree.only) {
          skipped++;
        }
        if (tree.only && node.only) {
          skipped--;
        }
        if (!(node.pending || node.skip || skipping)) {
          if (tree.only) {
            if (node.only) {
              if (node.error) {
                failed++;
              } else {
                passed++;
              }
            }
          } else {
            if (node.error) {
              failed++;
            } else {
              passed++;
            }
          }
        }
      }
      if (node.type === 'context') {
        if (node.skip) {
          skipping = true;
        }
      }
      if (node.children != null) {
        ref = node.children;
        results = [];
        for (l = 0, len2 = ref.length; l < len2; l++) {
          child = ref[l];
          results.push(recurse(child, skipping));
        }
        return results;
      }
    };
    recurse(tree);
    failedMsg = 'fail: 0  ';
    passedMsg = 'pass: 0  ';
    skipMsg = 'skip: 0  ';
    pendMsg = 'pend: 0';
    if (failed > 0) {
      failedMsg = ("fail: " + failed + "  ").red.bold;
    }
    if (passed > 0) {
      passedMsg = ("pass: " + passed + "  ").green.bold;
    }
    if (skipped > 0) {
      skipMsg = ("skip: " + skipped + "  ").cyan.bold;
    }
    if (pending > 0) {
      pendMsg = ("pend: " + pending).yellow.bold;
    }
    return console.log("\n   " + failedMsg + " " + passedMsg + " " + skipMsg + " " + pendMsg + "   time: " + totalDuration + "ms");
  });
  return pipe.on('dev.test.after.each', function(arg) {
    var string, test, testName, testPath;
    test = arg.test;
    try {
      testPath = test.node.path.slice(1);
      testPath[testPath.length - 1] = testPath[testPath.length - 1].bold;
      testName = testPath.join(' + ');
    } catch (_error) {}
    test.duration = test.endedAt - test.startedAt;
    if (test.type !== 'test') {
      if (test.error != null) {
        if (firstfail) {
          console.log();
        }
        firstfail = false;
        TODO('linkable stack on console.click to sublime plugin got location');
        console.log(("ERROR".red + ("in " + test.type).bold).underline);
        walkStack(test.error);
      }
      return;
    }
    if (test.error == null) {
      process.stdout.write('*'.green);
      firstfail = true;
      return;
    }
    if (firstfail) {
      console.log();
    }
    firstfail = false;
    console.log(('FAILED '.red + testName).underline);
    if (test.error.name === 'AssertionError') {
      showAssertionError(test.error);
      return;
    } else if (test.error.name === 'ExpectationError') {
      console.log(test.error.stack.split(EOL)[0].bold.red);
      try {
        string = JSON.stringify(test.error.detail, null, 3);
        console.log(string);
      } catch (_error) {}
      return;
    }
    return walkStack(test.error);
  });
};

showAssertionError = function(error) {
  TODO('Assertion diff');
  return console.log(error.toString());
};

walkStack = function(error) {
  var colNo, count, file, j, len, line, lineNo, m, ref, ref1, ref2, results, stack;
  stack = error.stack.split(EOL);
  console.log(stack[0].bold.red);
  count = 0;
  ref = stack.slice(1);
  results = [];
  for (j = 0, len = ref.length; j < len; j++) {
    line = ref[j];
    if (count < dev.walkDepth) {
      console.log(line.bold);
    } else if (count === dev.walkDepth) {
      console.log("\n" + line);
    } else {
      console.log(line);
    }
    try {
      if (line.match(/\)$/)) {
        ref1 = line.match(/\((.*):(\d+)\:(\d+)\)/), m = ref1[0], file = ref1[1], lineNo = ref1[2], colNo = ref1[3];
      } else {
        ref2 = line.match(/at\ (.*):(\d+)\:(\d+)$/), m = ref2[0], file = ref2[1], lineNo = ref2[2], colNo = ref2[3];
      }
      if (!(count >= dev.walkDepth)) {
        showCode(file, lineNo, colNo);
      }
    } catch (_error) {}
    results.push(count++);
  }
  return results;
};

showCode = function(file, line, col) {
  var i, j, lines, ref, results;
  lines = fs.readFileSync(file).toString().split(EOL);
  line = parseInt(line);
  results = [];
  for (i = j = 0, ref = lines.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
    if (!(i + dev.walkWidth > line)) {
      continue;
    }
    if (!(i - dev.walkWidth < line)) {
      continue;
    }
    if (line !== i + 1) {
      console.log(lines[i].grey);
    }
    if (line === i + 1) {
      results.push(console.log(lines[i].red));
    } else {
      results.push(void 0);
    }
  }
  return results;
};
