// Generated by CoffeeScript 1.9.2
var EOL, TODO, accum, colors, debug, enabled, error, firstfail, fs, info, initialised, logger, pipeline, showAssertionError, showCode, walkStack;

logger = objective.logger, pipeline = objective.pipeline;

info = logger.info, error = logger.error, TODO = logger.TODO;

debug = logger.createDebug('default:reporter');

colors = require('colors');

EOL = require('os').EOL;

TODO('Final stats after test (or test all)');

TODO('runs initiated by file changes may overlap, fix (perhaps {noOvertake} pipe on change watcher');

TODO('test timeouts error');

TODO('reporter calls null tests pending - actually bdd does it');

TODO('only walk from test onward, or ignore objective-dev');

fs = require('fs');

firstfail = false;

initialised = false;

enabled = void 0;

accum = {
  pass: 0,
  fail: 0,
  skip: 0,
  pend: 0,
  test: 0,
  hook: 0
};

module.exports.disable = function() {
  return enabled = false;
};

module.exports.enable = function() {
  enabled = true;
  if (initialised) {
    return;
  }
  initialised = true;
  debug('using default test reporter');
  pipeline.on('multiple.objectives.done', function(data) {
    var failed, failedMsg, passed, passedMsg, pendMsg, pending, skipMsg, skipped, totalHookDuration, totalTestDuration;
    failed = accum.fail;
    passed = accum.pass;
    skipped = accum.skip;
    pending = accum.pend;
    totalTestDuration = accum.test;
    totalHookDuration = accum.hook;
    failedMsg = 'fail: 0  ';
    passedMsg = 'pass: 0  ';
    skipMsg = 'skip: 0  ';
    pendMsg = 'pend: 0';
    if (failed > 0) {
      failedMsg = ("fail: " + failed + "  ").red.bold;
    }
    if (passed > 0) {
      passedMsg = ("pass: " + passed + "  ").green.bold;
    }
    if (skipped > 0) {
      skipMsg = ("skip: " + skipped + "  ").cyan.bold;
    }
    if (pending > 0) {
      pendMsg = ("pend: " + pending).yellow.bold;
    }
    console.log("\n  " + failedMsg + " " + passedMsg + " " + skipMsg + " " + pendMsg + "   test: " + totalTestDuration + "ms   hook: " + totalHookDuration + "ms");
    return data.exitCode = failed;
  });
  pipeline.on('dev.test.before.all', function(payload) {});
  pipeline.on('dev.test.after.all', function(arg) {
    var failed, failedMsg, passed, passedMsg, pendMsg, pending, skipMsg, skipped, stats, totalHookDuration, totalTestDuration;
    stats = arg.stats;
    if (!enabled) {
      return;
    }
    failedMsg = 'fail: 0  ';
    passedMsg = 'pass: 0  ';
    skipMsg = 'skip: 0  ';
    pendMsg = 'pend: 0';
    failed = stats.failed, passed = stats.passed, skipped = stats.skipped, pending = stats.pending, totalTestDuration = stats.totalTestDuration, totalHookDuration = stats.totalHookDuration;
    if (objective.noRoot) {
      accum.fail += failed;
      accum.pass += passed;
      accum.skip += skipped;
      accum.pend += pending;
      accum.test += totalTestDuration;
      accum.hook += totalHookDuration;
      return;
    }
    if (failed > 0) {
      failedMsg = ("fail: " + failed + "  ").red.bold;
    }
    if (passed > 0) {
      passedMsg = ("pass: " + passed + "  ").green.bold;
    }
    if (skipped > 0) {
      skipMsg = ("skip: " + skipped + "  ").cyan.bold;
    }
    if (pending > 0) {
      pendMsg = ("pend: " + pending).yellow.bold;
    }
    return console.log("\n  " + failedMsg + " " + passedMsg + " " + skipMsg + " " + pendMsg + "   test: " + totalTestDuration + "ms   hook: " + totalHookDuration + "ms");
  });
  return pipeline.on('dev.test.after.each', function(arg) {
    var j, len, line, ref, string, test, testName, testPath;
    test = arg.test;
    if (!enabled) {
      return;
    }
    try {
      testPath = test.node.path.slice(0);
      testPath[testPath.length - 1] = testPath[testPath.length - 1].bold;
      testName = testPath.join(' + ');
    } catch (_error) {}
    test.duration = test.endedAt - test.startedAt;
    if (test.type !== 'test') {
      if (test.error != null) {
        if (firstfail) {
          console.log();
        }
        firstfail = false;
        TODO('linkable stack on console.click to sublime plugin got location');
        if (!objective.plugins.dev.showError) {
          console._stdout.write('X'.red);
          return;
        }
        console.log("ERROR".red.bold + (" in " + test.type + " - " + testName));
        console.log("  (" + test.filename + ")");
        walkStack(test.error);
      }
      return;
    }
    if (test.error == null) {
      console._stdout.write('*'.green);
      firstfail = true;
      return;
    }
    if (test.error != null) {
      if (!objective.plugins.dev.showError) {
        console._stdout.write('*'.red);
        return;
      }
    }
    if (firstfail) {
      console.log();
    }
    firstfail = false;
    console.log('FAILED '.red.bold + testName);
    console.log("  (" + test.filename + ")");
    if (test.error.name === 'AssertionError') {
      showAssertionError(test.error);
      return;
    } else if (test.error.name === 'ExpectationError') {
      console.log("  " + test.error.stack.split(EOL)[0].bold.red);
      try {
        string = JSON.stringify(test.error.detail, null, 3);
        ref = string.split(EOL);
        for (j = 0, len = ref.length; j < len; j++) {
          line = ref[j];
          line = line.replace('ERROR', 'ERROR'.bold.red);
          line = line.replace('OK', 'OK'.bold.green);
          console.log("  " + line);
        }
      } catch (_error) {}
      return;
    }
    return walkStack(test.error);
  });
};

showAssertionError = function(error) {
  TODO('Assertion diff');
  return console.log("  " + error.toString());
};

walkStack = function(error) {
  var colNo, count, file, j, len, line, lineNo, m, ref, ref1, ref2, results, stack;
  try {
    stack = error.stack.split(EOL);
    console.log("  " + stack[0].bold.red);
    count = 0;
    ref = stack.slice(1);
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      line = ref[j];
      if (count < objective.plugins.dev.walkDepth) {
        console.log(line.bold);
      } else if (count === objective.plugins.dev.walkDepth) {
        console.log("\n" + line);
      } else {
        console.log(line);
      }
      try {
        if (line.match(/\)$/)) {
          ref1 = line.match(/\((.*):(\d+)\:(\d+)\)/), m = ref1[0], file = ref1[1], lineNo = ref1[2], colNo = ref1[3];
        } else {
          ref2 = line.match(/at\ (.*):(\d+)\:(\d+)$/), m = ref2[0], file = ref2[1], lineNo = ref2[2], colNo = ref2[3];
        }
        if (!(count >= dev.walkDepth)) {
          showCode(file, lineNo, colNo);
        }
      } catch (_error) {}
      results.push(count++);
    }
    return results;
  } catch (_error) {}
};

showCode = function(file, line, col) {
  var i, j, lines, ref, results;
  lines = fs.readFileSync(file).toString().split(EOL);
  line = parseInt(line);
  results = [];
  for (i = j = 0, ref = lines.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
    if (!(i + objective.plugins.dev.walkWidth > line)) {
      continue;
    }
    if (!(i - objective.plugins.dev.walkWidth < line)) {
      continue;
    }
    if (line !== i + 1) {
      console.log(lines[i].grey);
    }
    if (line === i + 1) {
      results.push(console.log(lines[i].red));
    } else {
      results.push(void 0);
    }
  }
  return results;
};
