// Generated by CoffeeScript 1.9.2
var config, expector, fs, path;

path = require('path');

fs = require('fs');

config = void 0;

expector = require('./expector');

module.exports.mocks = {};

module.exports.before = function(conf) {
  return config = conf;
};

module.exports.register = function(name, object) {
  var createdAt, createdIn, fail, node, recurse, test, type;
  try {
    test = dev.running.test;
    type = test.type;
    node = test.node;
  } catch (_error) {}
  if (module.exports.mocks[name] == null) {
    return module.exports.mocks[name] = {
      object: object,
      createdIn: type,
      createdAt: node
    };
  }
  fail = function(msg) {
    var e;
    e = new Error(msg);
    e.name = 'InjectionError';
    throw e;
  };
  if (!((test != null) && (type != null) && (node != null))) {
    return fail("Cannot overwrite existing alias '" + name + "'");
  }
  createdIn = module.exports.mocks[name].createdIn;
  createdAt = module.exports.mocks[name].createdAt;
  if (createdAt.id === node.id) {
    return fail("Cannot overwrite alias '" + name + "' created in Sibling test node.");
  }
  recurse = function(parent) {
    if (createdAt.id === parent.id) {
      return fail("Cannot overwrite alias '" + name + "' created in Ancestor test node.");
    }
    if (parent.parent != null) {
      return recurse(parent.parent);
    }
  };
  if (node.parent != null) {
    recurse(node.parent);
  }
  return module.exports.mocks[name] = {
    object: object,
    createdIn: type,
    createdAt: node
  };
};

module.exports.load = function(name) {
  var caps, e, i, j, k, len, matches, modpath, parts, possible, recurse, ref, ref1, tries;
  if (module.exports.mocks[name] != null) {
    return module.exports.mocks[name].object;
  }
  if (name === 'Subject' || name === 'subject') {
    modpath = config.filename.replace(new RegExp("^" + dev.testDir), dev.sourceDir);
    modpath = modpath.replace('_spec.', '.');
    try {
      return expector.create(require(process.cwd() + path.sep + modpath));
    } catch (_error) {
      e = _error;
      console.log("Subject injection failed. " + (e.toString()));
      return {};
    }
  }
  if (name.match(/^[A-Z]/)) {
    caps = name.match(/[A-Z]/g);
    parts = name.split(/[A-Z]/);
    parts.shift();
    tries = ['', '', ''];
    for (i = j = 0, ref = caps.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
      if (i !== 0) {
        tries[0] += '_';
      }
      tries[0] += caps[i].toLowerCase();
      tries[0] += parts[i].toLowerCase();
      if (i !== 0) {
        tries[1] += '-';
      }
      tries[1] += caps[i].toLowerCase();
      tries[1] += parts[i].toLowerCase();
      if (i === 0) {
        tries[2] += caps[i].toLowerCase();
      }
      if (i > 0) {
        tries[2] += caps[i];
      }
      tries[2] += parts[i].toLowerCase();
    }
    if ((tries[0] === (ref1 = tries[1]) && ref1 === tries[2])) {
      tries.length = 1;
    }
    matches = [];
    for (k = 0, len = tries.length; k < len; k++) {
      possible = tries[k];
      recurse = function(directory) {
        var file, files, l, len1, results, stat;
        files = fs.readdirSync(directory);
        results = [];
        for (l = 0, len1 = files.length; l < len1; l++) {
          file = files[l];
          stat = fs.lstatSync(directory + path.sep + file);
          if (!stat.isDirectory()) {
            if (file.match(new RegExp("^" + possible + "."))) {
              matches.push(directory + path.sep + file);
            }
            continue;
          }
          results.push(recurse(directory + path.sep + file));
        }
        return results;
      };
      recurse(process.cwd() + path.sep + dev.sourceDir);
    }
    if (matches.length === 1) {
      return expector.create(require(matches[0]));
    }
    if (matches.length === 0) {
      e = new Error("No injection match for '" + name + "'");
      e.matches = matches;
      throw e;
    }
    if (matches.length > 1) {
      e = new Error("Multiple injection matches for '" + name + "'");
      e.matches = matches;
      throw e;
    }
  }
  return expector.create(require(name));
};
