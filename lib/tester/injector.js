// Generated by CoffeeScript 1.9.2
var TODO, config, debug, error, expector, fs, info, logger, path;

path = require('path');

fs = require('fs');

config = void 0;

expector = require('./expector');

module.exports.mocks = {};

logger = objective.logger;

TODO = logger.TODO, debug = logger.debug, error = logger.error, info = logger.info;

module.exports.$$beforeEach = function(conf) {
  return config = conf;
};

module.exports.register = function(name, object) {
  var node, test, type;
  try {
    test = objective.plugins.dev.running.test;
    type = test.type;
    node = test.node;
  } catch (_error) {}
  if (module.exports.mocks[name] == null) {
    return module.exports.mocks[name] = {
      object: object,
      createdIn: type,
      createdAt: node
    };
  }
  TODO('Sensible prevent of mock (alias) overwrite');
  return module.exports.mocks[name] = {
    object: object,
    createdIn: type,
    createdAt: node
  };
};

module.exports.load = function(name) {
  var caps, e, i, j, k, len, matches, modpath, named, parts, possible, recurse, ref, ref1, tries;
  named = function(object) {
    if (object == null) {
      return;
    }
    Object.defineProperty(object, '$$name', {
      value: name,
      enumerable: false
    });
    return object;
  };
  if (module.exports.mocks[name] != null) {
    return named(module.exports.mocks[name].object);
  }
  if (name === 'Subject' || name === 'subject') {
    modpath = config.filename.replace(new RegExp("^" + dev.testDir), objective.plugins.dev.sourceDir);
    modpath = modpath.replace('_spec.', '.');
    try {
      return named(expector.create(require(process.cwd() + path.sep + modpath)));
    } catch (_error) {
      e = _error;
      console.log("Subject injection failed. " + (e.toString()));
      return named({});
    }
  }
  TODO('also search for camel exact match');
  if (name.match(/^[A-Z]/)) {
    caps = name.match(/[A-Z]/g);
    parts = name.split(/[A-Z]/);
    parts.shift();
    tries = ['', '', ''];
    for (i = j = 0, ref = caps.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
      if (i !== 0) {
        tries[0] += '_';
      }
      tries[0] += caps[i].toLowerCase();
      tries[0] += parts[i].toLowerCase();
      if (i !== 0) {
        tries[1] += '-';
      }
      tries[1] += caps[i].toLowerCase();
      tries[1] += parts[i].toLowerCase();
      if (i === 0) {
        tries[2] += caps[i].toLowerCase();
      }
      if (i > 0) {
        tries[2] += caps[i];
      }
      tries[2] += parts[i].toLowerCase();
    }
    if ((tries[0] === (ref1 = tries[1]) && ref1 === tries[2])) {
      tries.length = 1;
    }
    matches = [];
    for (k = 0, len = tries.length; k < len; k++) {
      possible = tries[k];
      recurse = function(directory) {
        var file, files, l, len1, results, stat;
        files = fs.readdirSync(directory);
        results = [];
        for (l = 0, len1 = files.length; l < len1; l++) {
          file = files[l];
          stat = fs.lstatSync(directory + path.sep + file);
          if (!stat.isDirectory()) {
            if (file.match(new RegExp("^" + possible + "."))) {
              matches.push(directory + path.sep + file);
            }
            continue;
          }
          results.push(recurse(directory + path.sep + file));
        }
        return results;
      };
      recurse(process.cwd() + path.sep + objective.plugins.dev.sourceDir);
    }
    if (matches.length === 1) {
      return named(expector.create(require(matches[0])));
    }
    if (matches.length === 0) {
      e = new Error("No injection match for '" + name + "'");
      e.matches = matches;
      throw e;
    }
    if (matches.length > 1) {
      e = new Error("Multiple injection matches for '" + name + "'");
      e.matches = matches;
      throw e;
    }
  }
  return named(expector.create(require(name)));
};
