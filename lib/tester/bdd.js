// Generated by CoffeeScript 1.9.2
var When, begin, createNode, deferred, end, injector, pointer, ref1, runTests, running, sequence, tree, util;

ref1 = require('also'), When = ref1.When, sequence = ref1.sequence, deferred = ref1.deferred, util = ref1.util;

injector = require('./injector');

running = void 0;

tree = void 0;

pointer = void 0;

module.exports.before = function(config) {
  var key;
  for (key in tree) {
    delete tree[key];
  }
  console.log('Loading tests...');
  running = When.defer();
  running.promise.start = runTests;
  tree = createNode(null, 'root', 'root', function() {});
  pointer = tree;
  tree.only = false;
  return true;
};

createNode = function(parent, type, str, fn, skip) {
  var path, recurse;
  recurse = function(parent, parts) {
    if (parts == null) {
      parts = [];
    }
    parts.push(parent.str);
    if (parent.parent == null) {
      return parts;
    }
    return recurse(parent.parent, parts);
  };
  try {
    path = '/' + (recurse(parent, [str])).reverse().join('/');
  } catch (_error) {}
  return {
    hooks: {
      beforeAll: [],
      beforeEach: [],
      afterEach: [],
      afterAll: []
    },
    type: type,
    str: str,
    fn: fn || function() {},
    skip: skip,
    pending: fn == null,
    children: [],
    parent: parent,
    path: path
  };
};

begin = function() {
  return running != null;
};

end = function() {
  return running.promise;
};

runTests = function() {
  var recurse;
  console.log('Running tests...');
  recurse = function(pointer, functions) {
    var child, children, context, fn, i, j, k, l, len, len1, len2, len3, len4, m, parent, recurse2, recurse3, ref, ref2, ref3, ref4, ref5, test, type;
    if (functions == null) {
      functions = [];
    }
    parent = pointer.parent, children = pointer.children, type = pointer.type;
    if ((parent != null) && type === 'it' && (!tree.only || pointer.only)) {
      recurse2 = function(parent, functions) {
        var fn, i, len, ref2;
        if (functions == null) {
          functions = [];
        }
        ref2 = parent.hooks.beforeEach.reverse();
        for (i = 0, len = ref2.length; i < len; i++) {
          fn = ref2[i];
          functions.push({
            fn: fn,
            node: pointer,
            type: 'beforeEach'
          });
        }
        if (parent.parent == null) {
          return functions;
        }
        return recurse2(parent.parent, functions);
      };
      ref2 = recurse2(parent).reverse();
      for (i = 0, len = ref2.length; i < len; i++) {
        ref = ref2[i];
        functions.push(ref);
      }
    }
    ref3 = pointer.hooks.beforeAll;
    for (j = 0, len1 = ref3.length; j < len1; j++) {
      fn = ref3[j];
      functions.push({
        fn: fn,
        node: pointer,
        type: 'beforeAll'
      });
    }
    if (!pointer.skip) {
      if (type === 'it') {
        if (tree.only) {
          if (pointer.only) {
            functions.push({
              fn: pointer.fn,
              node: pointer,
              type: 'test'
            });
          }
        } else {
          functions.push({
            fn: pointer.fn,
            node: pointer,
            type: 'test'
          });
        }
      } else {
        for (k = 0, len2 = children.length; k < len2; k++) {
          child = children[k];
          recurse(child, functions);
        }
      }
    }
    if ((parent != null) && type === 'it' && (!tree.only || pointer.only)) {
      recurse3 = function(parent, functions) {
        var l, len3, ref4;
        if (functions == null) {
          functions = [];
        }
        ref4 = parent.hooks.afterEach;
        for (l = 0, len3 = ref4.length; l < len3; l++) {
          fn = ref4[l];
          functions.push({
            fn: fn,
            node: pointer,
            type: 'afterEach'
          });
        }
        if (parent.parent == null) {
          return functions;
        }
        return recurse3(parent.parent, functions);
      };
      ref4 = recurse3(parent);
      for (l = 0, len3 = ref4.length; l < len3; l++) {
        ref = ref4[l];
        functions.push(ref);
      }
    }
    ref5 = pointer.hooks.afterAll;
    for (m = 0, len4 = ref5.length; m < len4; m++) {
      fn = ref5[m];
      functions.push({
        fn: fn,
        node: pointer,
        type: 'afterAll'
      });
    }
    if (type !== 'root') {
      return;
    }
    context = {};
    return sequence((function() {
      var len5, n, results;
      results = [];
      for (n = 0, len5 = functions.length; n < len5; n++) {
        test = functions[n];
        results.push((function(test) {
          return deferred(function(arg1) {
            var arg, doWithArgs, done, e, len6, notify, o, ref6, reject, resolve, timeout, tooSlow;
            resolve = arg1.resolve, reject = arg1.reject, notify = arg1.notify;
            try {
              timeout = void 0;
              done = void 0;
              if (test.node.pending) {
                return resolve();
              }
              if (test.node.skip) {
                return resolve();
              }
              test.args = util.argsOf(test.fn);
              context.test = test;
              tooSlow = function() {
                console.log('timeout!');
                return resolve();
              };
              context.timeout = function(value) {
                if (timeout == null) {
                  return;
                }
                if (typeof value !== 'number') {
                  return;
                }
                clearTimeout(timeout);
                return timeout = setTimeout(tooSlow, value);
              };
              doWithArgs = [];
              ref6 = test.args;
              for (o = 0, len6 = ref6.length; o < len6; o++) {
                arg = ref6[o];
                if (arg === 'done') {
                  timeout = setTimeout(tooSlow, 2000);
                  doWithArgs.push(done = function() {
                    clearTimeout(timeout);
                    return resolve();
                  });
                } else {
                  doWithArgs.push(injector.load(arg));
                }
              }
              try {
                test.fn.apply(context, doWithArgs);
                if (done == null) {
                  return resolve();
                }
              } catch (_error) {
                e = _error;
                if (timeout != null) {
                  clearTimeout(timeout);
                }
                if (test.type === 'test') {
                  console.log({
                    testError: e.toString()
                  });
                  return resolve();
                }
                return reject(e);
              }
            } catch (_error) {
              e = _error;
              return reject(e);
            }
          });
        })(test));
      }
      return results;
    })()).then(function(result) {
      running.resolve(result);
      running = void 0;
      return tree = void 0;
    }, function(error) {
      running.reject(error);
      running = void 0;
      return tree = void 0;
    }, function(notify) {
      return running.notify(notify);
    });
  };
  return recurse(tree);
};

global.before = function(fn) {
  if (!begin()) {
    return;
  }
  if (typeof fn === 'object') {
    if ((fn.each != null) && typeof fn.each === 'function') {
      pointer.hooks.beforeEach.push(fn.each);
    }
    if ((fn.all != null) && typeof fn.all === 'function') {
      pointer.hooks.beforeAll.push(fn.all);
    }
  } else {
    if (typeof fn === 'function') {
      pointer.hooks.beforeAll.push(fn);
    }
  }
  return end();
};

global.beforeAll = function(fn) {
  if (!begin()) {
    return;
  }
  if (typeof fn === 'function') {
    pointer.hooks.beforeAll.push(fn);
  }
  return end();
};

global.beforeEach = function(fn) {
  if (!begin()) {
    return;
  }
  if (typeof fn === 'function') {
    pointer.hooks.beforeEach.push(fn);
  }
  return end();
};

global.afterEach = function(fn) {
  if (!begin()) {
    return;
  }
  if (typeof fn === 'function') {
    pointer.hooks.afterEach.push(fn);
  }
  return end();
};

global.afterAll = function(fn) {
  if (!begin()) {
    return;
  }
  if (typeof fn === 'function') {
    pointer.hooks.afterAll.push(fn);
  }
  return end();
};

global.after = function(fn) {
  if (!begin()) {
    return;
  }
  if (typeof fn === 'object') {
    if ((fn.each != null) && typeof fn.each === 'function') {
      pointer.hooks.afterEach.push(fn.each);
    }
    if ((fn.all != null) && typeof fn.all === 'function') {
      pointer.hooks.afterAll.push(fn.all);
    }
  } else {
    if (typeof fn === 'function') {
      pointer.hooks.afterAll.push(fn);
    }
  }
  return end();
};

global.context = function(str, fn) {
  var prevPointer, skip;
  if (!begin()) {
    return;
  }
  skip = false;
  if (fn == null) {
    pointer.children.push(createNode(pointer, 'context', str, fn, skip));
    return end();
  }
  prevPointer = pointer;
  pointer.children.push(createNode(pointer, 'context', str, fn, skip));
  pointer = pointer.children.slice(-1)[0];
  fn();
  pointer = prevPointer;
  return end();
};

global.xcontext = function(str, fn) {
  var prevPointer, skip;
  if (!begin()) {
    return;
  }
  skip = true;
  if (fn == null) {
    pointer.children.push(createNode(pointer, 'context', str, fn, skip));
    return end();
  }
  prevPointer = pointer;
  pointer.children.push(createNode(pointer, 'context', str, fn, skip));
  pointer = pointer.children.slice(-1)[0];
  fn();
  pointer = prevPointer;
  return end();
};

global.describe = function(str, fn) {
  var prevPointer, skip;
  if (!begin()) {
    return;
  }
  skip = false;
  if (fn == null) {
    pointer.children.push(createNode(pointer, 'describe', str, fn, skip));
    return end();
  }
  prevPointer = pointer;
  pointer.children.push(createNode(pointer, 'describe', str, fn, skip));
  pointer = pointer.children.slice(-1)[0];
  fn();
  pointer = prevPointer;
  return end();
};

global.xdescribe = function(str, fn) {
  var prevPointer, skip;
  if (!begin()) {
    return;
  }
  skip = true;
  if (fn == null) {
    pointer.children.push(createNode(pointer, 'describe', str, fn, skip));
    return end();
  }
  prevPointer = pointer;
  pointer.children.push(createNode(pointer, 'describe', str, fn, skip));
  pointer = pointer.children.slice(-1)[0];
  fn();
  pointer = prevPointer;
  return end();
};

global.it = function(str, fn) {
  var skip;
  if (!begin()) {
    return;
  }
  skip = false;
  pointer.children.push(createNode(pointer, 'it', str, fn, skip));
  return end();
};

global.it.only = function(str, fn) {
  var skip;
  if (!begin()) {
    return;
  }
  skip = false;
  pointer.children.push(createNode(pointer, 'it', str, fn, skip));
  pointer.children.slice(-1)[0].only = true;
  tree.only = true;
  return end();
};

global.xit = function(str, fn) {
  var skip;
  if (!begin()) {
    return;
  }
  skip = true;
  pointer.children.push(createNode(pointer, 'it', str, fn, skip));
  return end();
};
