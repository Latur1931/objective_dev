// Generated by CoffeeScript 1.9.2
var When, begin, context, createNode, debug, deferred, end, error, info, injector, logger, pipe, pointer, ref1, runTests, running, sequence, tree, util, xcontext;

try {
  pipe = objective.pipe;
  pipe.createEvent('dev.test.before.all');
  pipe.createEvent('dev.test.after.all');
  pipe.createEvent('dev.test.before.each');
  pipe.createEvent('dev.test.after.each');
  logger = objective.logger;
  info = logger.info, debug = logger.debug, error = logger.error;
} catch (_error) {
  console.log('not running objective');
  process.exit(1);
}

ref1 = require('also'), When = ref1.When, sequence = ref1.sequence, deferred = ref1.deferred, util = ref1.util;

injector = require('./injector');

running = void 0;

tree = void 0;

pointer = void 0;

module.exports.before = function(config) {
  var key;
  for (key in tree) {
    delete tree[key];
  }
  debug('loading tests...');
  running = When.defer();
  running.promise.start = runTests;
  tree = createNode(null, 'root', 'root', function() {});
  pointer = tree;
  tree.only = false;
  return true;
};

createNode = function(parent, type, str, fn, skip) {
  var namePath, node, recurse;
  recurse = function(parent, parts) {
    if (parts == null) {
      parts = [];
    }
    parts.push(parent.str);
    if (parent.parent == null) {
      return parts;
    }
    return recurse(parent.parent, parts);
  };
  if (parent != null) {
    namePath = recurse(parent, [str]).reverse();
  }
  node = {
    hooks: {
      beforeAll: [],
      beforeEach: [],
      afterEach: [],
      afterAll: []
    },
    type: type,
    str: str,
    fn: fn || function() {},
    skip: skip,
    pending: fn == null,
    children: [],
    parent: parent,
    path: namePath,
    error: null
  };
  return node;
};

begin = function() {
  return running != null;
};

end = function() {
  return running.promise;
};

runTests = function() {
  return pipe.emit('dev.test.before.all', {
    tree: tree
  }, function(err) {
    var recurse;
    if (err != null) {
      return running.reject(err);
    }
    debug('running tests...');
    recurse = function(pointer, functions) {
      var child, children, context, fn, j, k, l, len, len1, len2, len3, len4, m, n, parent, recurse2, recurse3, ref, ref2, ref3, ref4, ref5, test, type;
      if (functions == null) {
        functions = [];
      }
      debug("recursing " + pointer.str);
      parent = pointer.parent, children = pointer.children, type = pointer.type;
      if ((parent != null) && type === 'it' && (!tree.only || pointer.only)) {
        recurse2 = function(parent, functions) {
          var fn, j, len, ref2;
          if (functions == null) {
            functions = [];
          }
          ref2 = parent.hooks.beforeEach.reverse();
          for (j = 0, len = ref2.length; j < len; j++) {
            fn = ref2[j];
            functions.push({
              fn: fn,
              node: pointer,
              type: 'beforeEach'
            });
          }
          if (parent.parent == null) {
            return functions;
          }
          return recurse2(parent.parent, functions);
        };
        ref2 = recurse2(parent).reverse();
        for (j = 0, len = ref2.length; j < len; j++) {
          ref = ref2[j];
          functions.push(ref);
        }
      }
      ref3 = pointer.hooks.beforeAll;
      for (k = 0, len1 = ref3.length; k < len1; k++) {
        fn = ref3[k];
        functions.push({
          fn: fn,
          node: pointer,
          type: 'beforeAll'
        });
      }
      if (!pointer.skip) {
        if (type === 'it') {
          if (tree.only) {
            if (pointer.only) {
              functions.push({
                fn: pointer.fn,
                node: pointer,
                type: 'test'
              });
            }
          } else {
            functions.push({
              fn: pointer.fn,
              node: pointer,
              type: 'test'
            });
          }
        } else {
          for (l = 0, len2 = children.length; l < len2; l++) {
            child = children[l];
            recurse(child, functions);
          }
        }
      }
      if ((parent != null) && type === 'it' && (!tree.only || pointer.only)) {
        recurse3 = function(parent, functions) {
          var len3, m, ref4;
          if (functions == null) {
            functions = [];
          }
          ref4 = parent.hooks.afterEach;
          for (m = 0, len3 = ref4.length; m < len3; m++) {
            fn = ref4[m];
            functions.push({
              fn: fn,
              node: pointer,
              type: 'afterEach'
            });
          }
          if (parent.parent == null) {
            return functions;
          }
          return recurse3(parent.parent, functions);
        };
        ref4 = recurse3(parent);
        for (m = 0, len3 = ref4.length; m < len3; m++) {
          ref = ref4[m];
          functions.push(ref);
        }
      }
      ref5 = pointer.hooks.afterAll;
      for (n = 0, len4 = ref5.length; n < len4; n++) {
        fn = ref5[n];
        functions.push({
          fn: fn,
          node: pointer,
          type: 'afterAll'
        });
      }
      if (type !== 'root') {
        return;
      }
      context = {};
      return sequence((function() {
        var len5, o, results;
        results = [];
        for (o = 0, len5 = functions.length; o < len5; o++) {
          test = functions[o];
          results.push((function(test) {
            return deferred(function(arg1) {
              var arg, doWithArgs, done, e, i, len6, len7, notify, p, q, ref6, ref7, reject, resolve, timeout, tooSlow;
              resolve = arg1.resolve, reject = arg1.reject, notify = arg1.notify;
              try {
                timeout = void 0;
                done = void 0;
                if (test.node.pending) {
                  return resolve();
                }
                if (test.node.skip) {
                  return resolve();
                }
                test.argNames = util.argsOf(test.fn);
                context.test = test;
                tooSlow = function() {
                  console.log('timeout!');
                  return resolve();
                };
                context.timeout = function(value) {
                  if (timeout == null) {
                    return;
                  }
                  if (typeof value !== 'number') {
                    return;
                  }
                  clearTimeout(timeout);
                  return timeout = setTimeout(tooSlow, value);
                };
                doWithArgs = [];
                ref6 = test.argNames;
                for (p = 0, len6 = ref6.length; p < len6; p++) {
                  arg = ref6[p];
                  if (arg === 'done') {
                    timeout = setTimeout(tooSlow, 2000);
                    doWithArgs.push(done = function() {
                      clearTimeout(timeout);
                      return pipe.emit('dev.test.after.each', {
                        test: test
                      }, function(err) {
                        if (err != null) {
                          return reject(err);
                        }
                        return resolve();
                      });
                    });
                  } else {
                    doWithArgs.push(injector.load(arg));
                  }
                }
                test["arguments"] = {};
                i = 0;
                ref7 = test.argNames;
                for (q = 0, len7 = ref7.length; q < len7; q++) {
                  arg = ref7[q];
                  test["arguments"][arg] = doWithArgs[i++];
                }
                test.error = null;
              } catch (_error) {
                e = _error;
                return reject(e);
              }
              return pipe.emit('dev.test.before.each', {
                test: test
              }, function(err) {
                if (err != null) {
                  if (timeout != null) {
                    clearTimeout(timeout);
                  }
                  return reject(err);
                }
                try {
                  debug("running '" + test.type + "' at '" + test.node.str + "'");
                  test.fn.apply(context, doWithArgs);
                  if (done != null) {
                    return;
                  }
                  return pipe.emit('dev.test.after.each', {
                    test: test
                  }, function(err) {
                    if (err != null) {
                      return reject(err);
                    }
                    return resolve();
                  });
                } catch (_error) {
                  e = _error;
                  if (timeout != null) {
                    clearTimeout(timeout);
                  }
                  test.error = e;
                  if (test.type === 'test') {
                    test.node.error = e;
                  }
                  return pipe.emit('dev.test.after.each', {
                    test: test
                  }, function(err) {
                    if (err != null) {
                      return reject(err);
                    }
                    if (test.type === 'test') {
                      return resolve();
                    }
                    return reject(e);
                  });
                }
              });
            });
          })(test));
        }
        return results;
      })()).then(function(result) {
        return pipe.emit('dev.test.after.all', {
          error: null,
          tree: tree,
          functions: functions
        }, function(err) {
          if (err != null) {
            running.reject(err);
            running = void 0;
            tree = void 0;
            return;
          }
          running.resolve(result);
          running = void 0;
          return tree = void 0;
        });
      }, function(error) {
        return pipe.emit('dev.test.after.all', {
          error: error,
          tree: tree,
          functions: functions
        }, function(err) {
          if (err != null) {
            running.reject(err);
            running = void 0;
            tree = void 0;
            return;
          }
          running.reject(error);
          running = void 0;
          return tree = void 0;
        });
      }, function(notify) {
        return running.notify(notify);
      });
    };
    return recurse(tree);
  });
};

global.before = function(fn) {
  if (!begin()) {
    return;
  }
  if (typeof fn === 'object') {
    if ((fn.each != null) && typeof fn.each === 'function') {
      pointer.hooks.beforeEach.push(fn.each);
    }
    if ((fn.all != null) && typeof fn.all === 'function') {
      pointer.hooks.beforeAll.push(fn.all);
    }
  } else {
    if (typeof fn === 'function') {
      pointer.hooks.beforeAll.push(fn);
    }
  }
  return end();
};

global.beforeAll = function(fn) {
  if (!begin()) {
    return;
  }
  if (typeof fn === 'function') {
    pointer.hooks.beforeAll.push(fn);
  }
  return end();
};

global.beforeEach = function(fn) {
  if (!begin()) {
    return;
  }
  if (typeof fn === 'function') {
    pointer.hooks.beforeEach.push(fn);
  }
  return end();
};

global.afterEach = function(fn) {
  if (!begin()) {
    return;
  }
  if (typeof fn === 'function') {
    pointer.hooks.afterEach.push(fn);
  }
  return end();
};

global.afterAll = function(fn) {
  if (!begin()) {
    return;
  }
  if (typeof fn === 'function') {
    pointer.hooks.afterAll.push(fn);
  }
  return end();
};

global.after = function(fn) {
  if (!begin()) {
    return;
  }
  if (typeof fn === 'object') {
    if ((fn.each != null) && typeof fn.each === 'function') {
      pointer.hooks.afterEach.push(fn.each);
    }
    if ((fn.all != null) && typeof fn.all === 'function') {
      pointer.hooks.afterAll.push(fn.all);
    }
  } else {
    if (typeof fn === 'function') {
      pointer.hooks.afterAll.push(fn);
    }
  }
  return end();
};

context = function(str, fn) {
  var prevPointer, skip;
  if (!begin()) {
    return;
  }
  skip = false;
  if (fn == null) {
    pointer.children.push(createNode(pointer, 'context', str, fn, skip));
    return end();
  }
  prevPointer = pointer;
  pointer.children.push(createNode(pointer, 'context', str, fn, skip));
  pointer = pointer.children.slice(-1)[0];
  fn();
  pointer = prevPointer;
  return end();
};

xcontext = function(str, fn) {
  var prevPointer, skip;
  if (!begin()) {
    return;
  }
  skip = true;
  if (fn == null) {
    pointer.children.push(createNode(pointer, 'context', str, fn, skip));
    return end();
  }
  prevPointer = pointer;
  pointer.children.push(createNode(pointer, 'context', str, fn, skip));
  pointer = pointer.children.slice(-1)[0];
  fn();
  pointer = prevPointer;
  return end();
};

global.context = context;

global.xcontext = xcontext;

global.describe = context;

global.xdescribe = xcontext;

global.it = function(str, fn) {
  var skip;
  if (!begin()) {
    return;
  }
  skip = false;
  pointer.children.push(createNode(pointer, 'it', str, fn, skip));
  return end();
};

global.it.only = function(str, fn) {
  var skip;
  if (!begin()) {
    return;
  }
  skip = false;
  pointer.children.push(createNode(pointer, 'it', str, fn, skip));
  pointer.children.slice(-1)[0].only = true;
  tree.only = true;
  return end();
};

global.xit = function(str, fn) {
  var skip;
  if (!begin()) {
    return;
  }
  skip = true;
  pointer.children.push(createNode(pointer, 'it', str, fn, skip));
  return end();
};
