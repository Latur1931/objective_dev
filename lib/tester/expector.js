// Generated by CoffeeScript 1.9.2
var TODO, config, debug, entities, error, info, injector, logger, original, pipe, shortid,
  slice = [].slice;

shortid = require('shortid');

injector = require('./injector');

pipe = objective.pipe, logger = objective.logger;

debug = logger.debug, error = logger.error, info = logger.info, TODO = logger.TODO;

TODO('how to create multiple expectations with does over and over');

TODO('reporter function/class name');

TODO('spy as not an expectation');

TODO('detect ipso, perhaps substitute');

module.exports.entities = entities = {};

config = void 0;

module.exports.$$beforeEach = function(conf) {
  return config = conf;
};

original = void 0;

Object.defineProperty(global, 'original', {
  configurable: false,
  get: function() {
    return original;
  }
});

module.exports.create = function(object) {
  var expectorNames, pendingContexts;
  try {
    Object.defineProperty(object, '$$id', {
      value: shortid.generate(),
      writable: false
    });
  } catch (_error) {}
  expectorNames = ['does', 'Does'];
  if ((object.does != null) && !object.does.toString().match(/MOCKER_FUNCTION/)) {
    expectorNames = ['$does', '$Does'];
  }
  object[expectorNames[0]] = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];

    /* .Does (for expectations on class methods) */
    args.unshift(true);
    return object[expectorNames[1]].apply(null, args);
  };
  pendingContexts = [];
  object[expectorNames[1]] = function() {
    var args, e, fn1, functions, i, len, name, onClass, testType;
    onClass = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];

    /* MOCKER_FUNCTION */

    /* .does (for expectations on instance methods) */
    try {
      testType = objective.plugins.dev.running.test.type;
    } catch (_error) {}
    if (['beforeAll', 'afterAll', 'afterEach'].indexOf(testType) !== -1) {
      throw (e = new Error('Cannot create expectation in ' + testType), e.name = 'ExpectationError', e);
    }
    pendingContexts.length = 0;
    if (typeof onClass !== 'boolean') {
      args.unshift(onClass);
      onClass = false;
    }
    for (i = 0, len = args.length; i < len; i++) {
      functions = args[i];
      fn1 = function(name) {
        var base, base1, base2, base3, base4, base5, expectation, fn, n, name1, o, objectType, stub, type;
        n = object.constructor.name;
        objectType = 'object';
        if (name === 'constructor') {
          e = new Error("Cannot manipulate constructor.");
          e.name = 'ExpectationError';
          throw e;
        }
        try {
          n = object.prototype.constructor.name;
          objectType = 'class';
        } catch (_error) {}
        o = entities[name1 = object.$$id] || (entities[name1] = {
          type: objectType,
          name: n,
          object: object,
          expectations: {},
          calls: {},
          originals: {}
        });
        type = 'mock';
        fn = functions[name];
        if (name.match(/^\$\$/)) {
          type = 'spy';
          name = name.slice(2);
        }
        (base = o.expectations)[name] || (base[name] = {});
        (base1 = o.expectations[name])[onClass] || (base1[onClass] = []);
        if (o.expectations[name][onClass].length > 0) {
          expectation = o.expectations[name][onClass].slice(-1)[0];
          if (expectation.type !== type) {
            throw new Error("Cannot '" + type + "' on own '" + expectation.type + "' in function '" + o.name + "." + name + "()'");
          }
        }
        o.expectations[name][onClass].push({
          type: type,
          fn: fn,
          context: null
        });
        pendingContexts.push(o.expectations[name][onClass].slice(-1)[0]);
        (base2 = o.calls)[name] || (base2[name] = {});
        (base3 = o.calls[name])[onClass] || (base3[onClass] = []);
        (base4 = o.originals)[name] || (base4[name] = {});
        (base5 = o.originals[name])[onClass] || (base5[onClass] = {});
        o.originals[name][onClass].type = objectType;
        if (objectType === 'class') {
          if (onClass) {
            o.originals[name][onClass].fn = object[name] || function() {

              /* NO_ORIGINAL */
            };
          } else {
            o.originals[name][onClass].fn = object.prototype[name] || function() {

              /* NO_ORIGINAL */
            };
          }
        } else {
          o.originals[name][onClass].fn = object[name] || function() {

            /* NO_ORIGINAL */
          };
        }
        if (object[name] != null) {
          if (object[name].toString().match(/EXPECTATION_STUB/)) {
            return;
          }
        }
        stub = function() {

          /* EXPECTATION_STUB */
          var call, context, expected, ref, result;
          expected = false;
          try {
            ref = entities[object.$$id].expectations[name][onClass].shift(), type = ref.type, fn = ref.fn, context = ref.context;
            if (type === 'spy') {
              entities[object.$$id].expectations[name][onClass].unshift({
                type: type,
                fn: fn,
                context: null
              });
            }
            original = entities[object.$$id].originals[name][onClass].fn;
            expected = true;
          } catch (_error) {}
          fn || (fn = function() {});
          entities[object.$$id].calls[name][onClass].push(call = {
            type: type,
            fn: fn,
            context: context,
            "arguments": arguments,
            expected: expected,
            error: null,
            result: null
          });
          if (type === 'spy') {
            original = entities[object.$$id].originals[name][onClass].fn || function() {};
          }
          try {
            call.result = result = fn.apply(context || object, arguments);
          } catch (_error) {
            e = _error;
            call.error = e;
          }
          if (original != null) {
            result = original.apply(context || object, arguments);
          }
          original = void 0;
          return result;
        };
        if (objectType !== 'class') {
          return object[name] = stub;
        }
        if (onClass === true) {
          return object[name] = stub;
        }
        return object.prototype[name] = stub;
      };
      for (name in functions) {
        fn1(name);
      }
    }
    return {
      as: function(context) {
        var expectation, j, len1, results;
        results = [];
        for (j = 0, len1 = pendingContexts.length; j < len1; j++) {
          expectation = pendingContexts[j];
          results.push(expectation.context = context);
        }
        return results;
      }
    };
  };
  return object;
};

module.exports.mock = function() {
  var args, name, object, result;
  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  if (typeof args[0] === 'string') {
    name = args[0];
    object = args[1] || {};
  } else {
    object = args[0];
  }
  result = module.exports.create(object);
  if (name != null) {
    injector.register(name, result);
    Object.defineProperty(result, '$$name', {
      value: name,
      enumerable: false
    });
  }
  return result;
};

Object.defineProperty(Object.prototype, 'mock', {
  value: module.exports.mock,
  configurable: false
});

pipe.on('dev.test.after.each', function(arg) {
  var calls, constructorName, e, errorString, errored, expectations, expected, failed, functionName, i, id, len, name, object, objectName, onClass, ref, ref1, ref2, remaining, report, result, runExpected, runUnexpected, test, type;
  test = arg.test;
  if (test.type !== 'test') {
    return;
  }
  if ((test.error != null) && test.error.name !== 'Timeout') {
    return;
  }
  debug('checking for failed expectations');
  failed = false;
  report = {};
  for (id in entities) {
    ref = entities[id], object = ref.object, expectations = ref.expectations, calls = ref.calls;
    try {
      constructorName = object.constructor.name;
      objectName = object.$$name + " [" + constructorName + "]";
    } catch (_error) {
      objectName = object.$$name;
    }
    report[objectName] || (report[objectName] = {
      functions: {}
    });
    errorString = "Function expectations were not met";
    for (name in expectations) {
      for (onClass in expectations[name]) {
        functionName = name + '()';
        remaining = expectations[name][onClass].length;
        if (remaining > 0) {
          type = expectations[name][onClass][0].type;
        }
        runExpected = 0;
        runUnexpected = 0;
        ref1 = calls[name][onClass];
        for (i = 0, len = ref1.length; i < len; i++) {
          ref2 = ref1[i], expected = ref2.expected, error = ref2.error;
          if (error != null) {
            errored = error;
          }
          if (expected) {
            runExpected++;
          }
          if (!expected) {
            runUnexpected++;
          }
        }
        if (errored != null) {
          result = {
            ERROR: errored.toString(),
            error: errored
          };
          errorString = "Exception in expectation";
          failed = true;
        } else if (remaining > 0) {
          if (type === 'spy') {
            result = {
              OK: "Ran spy " + runExpected + " times"
            };
          } else {
            result = {
              ERROR: "Ran " + runExpected + " times of expected " + (runExpected + remaining)
            };
            failed = true;
          }
        } else if (runUnexpected === 0) {
          if (type === 'spy') {
            result = {
              OK: "Ran spy " + runExpected + " times"
            };
          } else {
            result = {
              OK: "Ran " + runExpected + " times as expected"
            };
          }
        } else if (runUnexpected !== 0) {
          if (type === 'spy') {
            result = {
              OK: "Ran spy " + runExpected + " times"
            };
          } else {
            result = {
              ERROR: "Ran " + (runExpected + runUnexpected) + " times of expected " + runExpected
            };
            failed = true;
          }
        }
        report[objectName].functions[functionName] = result;
      }
    }
  }
  if (failed) {
    e = new Error(errorString);
    e.name = 'ExpectationError';
    e.detail = report;
    test.error = e;
    return test.node.error = e;
  }
});

pipe.on('dev.test.after.each', function(arg) {
  var calls, expectations, fn, id, name, object, onClass, originals, ref, results, test;
  test = arg.test;
  if (test.type !== 'test') {
    return;
  }
  debug('clear expectations');
  TODO('remove entities from injector if not still in play');
  TODO('remove expectations if no longer in play (deleted does and fn hangs about)');
  results = [];
  for (id in entities) {
    ref = entities[id], object = ref.object, originals = ref.originals, calls = ref.calls, expectations = ref.expectations;
    results.push((function() {
      var results1;
      results1 = [];
      for (name in originals) {
        for (onClass in originals[name]) {
          fn = originals[name][onClass].fn;
          if (fn.toString().match(/NO_ORIGINAL/)) {
            delete object[name];
            continue;
          }
          object[name] = fn;
        }
        delete calls[name];
        delete expectations[name];
        results1.push(delete originals[name]);
      }
      return results1;
    })());
  }
  return results;
});
