// Generated by CoffeeScript 1.9.2
var TODO, config, debug, entities, error, info, injector, logger, pipe, shortid,
  slice = [].slice;

shortid = require('shortid');

injector = require('./injector');

pipe = objective.pipe, logger = objective.logger;

debug = logger.debug, error = logger.error, info = logger.info, TODO = logger.TODO;

TODO('how to create multiple expectations with does over and over');

TODO('reporter function/class name');

module.exports.entities = entities = {};

config = void 0;

module.exports.before = function(conf) {
  return config = conf;
};

module.exports.create = function(object) {
  var expectorName, pendingContexts, upperExpectorName;
  expectorName = 'does';
  try {
    expectorName = dev.expectorName;
  } catch (_error) {}
  try {
    Object.defineProperty(object, '$$id', {
      value: shortid.generate(),
      writable: false
    });
  } catch (_error) {}
  upperExpectorName = expectorName[0].toUpperCase() + expectorName.slice(1);
  if (upperExpectorName === expectorName) {
    upperExpectorName = '$' + upperExpectorName;
  }
  object[upperExpectorName] = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];

    /* .Does (for expectations on class methods) */
    args.unshift(true);
    return object[expectorName].apply(null, args);
  };
  pendingContexts = [];
  object[expectorName] = function() {
    var args, fn1, functions, i, len, name, onClass;
    onClass = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];

    /* .does (for expectations on instance methods) */
    pendingContexts.length = 0;
    if (typeof onClass !== 'boolean') {
      args.unshift(onClass);
      onClass = false;
    }
    for (i = 0, len = args.length; i < len; i++) {
      functions = args[i];
      fn1 = function(name) {
        var base, base1, base2, e, fn, n, name1, o, objectType, stub, type;
        n = object.constructor.name;
        objectType = 'object';
        if (name === 'constructor') {
          e = new Error("Cannot manipulate constructor.");
          e.name = 'ExpectationError';
          throw e;
        }
        try {
          n = object.prototype.constructor.name;
          objectType = 'class';
        } catch (_error) {}
        o = entities[name1 = object.$$id] || (entities[name1] = {
          type: objectType,
          name: object.name || n,
          object: object,
          expectations: {},
          originals: {}
        });
        type = 'mock';
        fn = functions[name];
        if (name.match(/^\$\$/)) {
          type = 'spy';
          name = name.slice(2);
        }
        (base = o.expectations)[name] || (base[name] = []);
        o.expectations[name].push({
          type: type,
          fn: fn,
          context: null
        });
        pendingContexts.push(o.expectations[name].slice(-1)[0]);
        (base1 = o.originals)[name] || (base1[name] = {});
        (base2 = o.originals[name])[onClass] || (base2[onClass] = {});
        o.originals[name][onClass].type = objectType;
        if (objectType === 'class') {
          if (onClass) {
            o.originals[name][onClass].fn = object[name] || function() {

              /* NO_ORIGINAL */
            };
          } else {
            o.originals[name][onClass].fn = object.prototype[name] || function() {

              /* NO_ORIGINAL */
            };
          }
        } else {
          o.originals[name][onClass].fn = object[name] || function() {

            /* NO_ORIGINAL */
          };
        }
        if (object[name] != null) {
          if (object[name].toString().match(/EXPECTATION_STUB/)) {
            return;
          }
        }
        stub = function() {

          /* EXPECTATION_STUB */
          var context, original, ref, result;
          TODO('dont throw Too many calls, report number as exception after instead');
          try {
            ref = entities[object.$$id].expectations[name].shift(), type = ref.type, fn = ref.fn, context = ref.context;
          } catch (_error) {
            e = new Error("Too many calls to function '" + name + "()'");
            e.name = 'ExpectationError';
            throw e;
          }
          if (type === 'spy') {
            original = entities[object.$$id].originals[name][onClass].fn || function() {};
          }
          result = fn.apply(context || object, arguments);
          if (original != null) {
            result = original.apply(context || object, arguments);
          }
          return result;
        };
        if (objectType !== 'class') {
          return object[name] = stub;
        }
        if (onClass === true) {
          return object[name] = stub;
        }
        return object.prototype[name] = stub;
      };
      for (name in functions) {
        fn1(name);
      }
    }
    return {
      as: function(context) {
        var expectation, j, len1, results;
        results = [];
        for (j = 0, len1 = pendingContexts.length; j < len1; j++) {
          expectation = pendingContexts[j];
          results.push(expectation.context = context);
        }
        return results;
      }
    };
  };
  return object;
};

module.exports.mock = function() {
  var args, name, object, result;
  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  if (typeof args[0] === 'string') {
    name = args[0];
    object = args[1] || {};
  } else {
    object = args[0];
  }
  result = module.exports.create(object);
  if (name != null) {
    injector.register(name, result);
  }
  return result;
};

Object.defineProperty(Object.prototype, 'mock', {
  value: module.exports.mock,
  configurable: false
});

pipe.on('dev.test.after.each', function(arg) {
  var e, expectations, failed, funcName, id, name, name1, object, ref, report, test;
  test = arg.test;
  if (test.type !== 'test') {
    return;
  }
  if ((test.error != null) && test.error.name !== 'Timeout') {
    return;
  }
  debug('checking for failed expectations');
  failed = false;
  report = {};
  for (id in entities) {
    ref = entities[id], object = ref.object, expectations = ref.expectations;
    report[name1 = object.toString()] || (report[name1] = {});
    for (name in expectations) {
      funcName = name + '()';
      report[object.toString()][funcName] = 'OK';
      if (expectations[name].length > 0) {
        report[object.toString()][funcName] = "PROBLEM - " + expectations[name].length + " expectations remain";
        failed = true;
      }
    }
  }
  if (failed) {
    e = new Error("Function expectations were not met");
    e.name = 'ExpectationError';
    e.detail = report;
    test.error = e;
    return test.node.error = e;
  }
});

pipe.on('dev.test.after.each', function(arg) {
  var id, results, test;
  test = arg.test;
  if (test.type !== 'test') {
    return;
  }
  debug('clear expectations unless created in beforeAll?');
  TODO('EXPECTOR CLEARUP');
  results = [];
  for (id in entities) {
    results.push(delete entities[id]);
  }
  return results;
});
