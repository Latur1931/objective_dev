// Generated by CoffeeScript 1.9.2
var TODO, config, debug, entities, error, info, logger, pipe, shortid;

shortid = require('shortid');

pipe = objective.pipe, logger = objective.logger;

debug = logger.debug, error = logger.error, info = logger.info, TODO = logger.TODO;

TODO('how to create multiple expectations with does over and over');

TODO('reporter function/class name');

entities = {};

config = void 0;

module.exports.before = function(conf) {
  return config = conf;
};

module.exports.create = function(object) {
  try {
    Object.defineProperty(object, '$$id', {
      value: shortid.generate(),
      writable: false
    });
  } catch (_error) {}
  object.does = function(functions) {
    var name, results;
    results = [];
    for (name in functions) {
      results.push((function(name) {
        var base, base1, fn, name1, o, type;
        o = entities[name1 = object.$$id] || (entities[name1] = {
          object: object,
          expectations: {},
          originals: {}
        });
        type = 'mock';
        fn = functions[name];
        if (name.match(/^\$\$/)) {
          type = 'spy';
          name = name.slice(2);
        }
        (base = o.expectations)[name] || (base[name] = []);
        o.expectations[name].push({
          type: type,
          fn: fn
        });
        (base1 = o.originals)[name] || (base1[name] = object[name] || function() {

          /* NO_ORIGINAL */
        });
        if (object[name] != null) {
          if (object[name].toString().match(/EXPECTATION_STUB/)) {
            return;
          }
        }
        return object[name] = function() {

          /* EXPECTATION_STUB */
          var e, original, ref;
          try {
            ref = entities[object.$$id].expectations[name].shift(), type = ref.type, fn = ref.fn;
          } catch (_error) {
            e = new Error("Too many calls to function '" + name + "()'");
            e.name = 'ExpectationError';
            throw e;
          }
          if (type === 'spy') {
            original = entities[object.$$id].originals[name] || function() {};
          }
          fn.apply(object, arguments);
          if (original != null) {
            return original.apply(object, arguments);
          }
        };
      })(name));
    }
    return results;
  };
  return object;
};

pipe.on('dev.test.after.each', function(arg) {
  var e, expectations, failed, funcName, id, name, name1, object, originals, ref, report, test;
  test = arg.test;
  if (test.type !== 'test') {
    return;
  }
  if ((test.error != null) && test.error.name !== 'Timeout') {
    return;
  }
  debug('checking for failed expectations');
  failed = false;
  report = {};
  for (id in entities) {
    ref = entities[id], object = ref.object, expectations = ref.expectations, originals = ref.originals;
    report[name1 = object.toString()] || (report[name1] = {});
    for (name in expectations) {
      funcName = name + '()';
      report[object.toString()][funcName] = 'OK';
      if (expectations[name].length > 0) {
        report[object.toString()][funcName] = "PROBLEM - " + expectations[name].length + " expectations remain";
        failed = true;
      }
    }
  }
  if (failed) {
    e = new Error("Function expectations were not met");
    e.name = 'ExpectationError';
    e.detail = report;
    test.error = e;
    return test.node.error = e;
  }
});

pipe.on('dev.test.after.each', function(arg) {
  var fn, id, name, object, originals, ref, results, test;
  test = arg.test;
  if (test.type !== 'test') {
    return;
  }
  debug('clear expectations unless created in beforeAll?');
  for (id in entities) {
    ref = entities[id], object = ref.object, originals = ref.originals;
    for (name in originals) {
      fn = originals[name];
      if (fn.toString().match(/NO_ORIGINAL/)) {
        delete object[name];
        continue;
      }
      object[name] = fn;
    }
  }
  results = [];
  for (id in entities) {
    results.push(delete entities[id]);
  }
  return results;
});
