// Generated by CoffeeScript 1.9.2
var EOL, blessed, columnnumber, content, currentLine, currentTest, dirname, enabled, fails, filename, fs, linenumber, nextLines, nextTest, normalize, origPrepareStackTrace, pad, pipeline, previousLine, previousTest, ref, render, screen, sep, stack, stackReport, stepPosition, successCount, testPosition, text;

enabled = false;

origPrepareStackTrace = void 0;

module.exports.enable = function() {
  var dev, devnull, got, id;
  dev = require('../');
  origPrepareStackTrace = Error.prepareStackTrace;
  Error.prepareStackTrace = function(_, stack) {
    return stack;
  };
  got = false;
  for (id in objective.repls) {
    if (objective.repls[id].grabbed) {
      got = true;
    }
  }
  if (!got) {
    devnull = require('dev-null');
    console._stdout = devnull();
    console._stderr = devnull();
    objective.logger.setStream(devnull());
  }
  return enabled = true;
};

module.exports.disable = function() {
  Error.prepareStackTrace = origPrepareStackTrace;
  return enabled = false;
};

blessed = require('blessed');

require('colors');

screen = void 0;

content = '';

text = void 0;

fails = void 0;

testPosition = 0;

stepPosition = 0;

pad = require('pad');

fs = require('fs');

ref = require('path'), dirname = ref.dirname, normalize = ref.normalize, sep = ref.sep;

EOL = require('os').EOL;

stack = [];

successCount = 0;

filename = void 0;

linenumber = void 0;

columnnumber = void 0;

currentTest = function() {
  var fail, num, path, pathLength, type;
  num = fails.length - 1 - testPosition;
  fail = fails[fails.length - 1 - testPosition];
  type = fail.type === 'test' ? '' : "(" + fail.type + ") ";
  path = fail.node.path;
  pathLength = path.length;
  return ("" + (pad(2, (num + 1).toString(), '0'))).bold + " FAILED ".red.bold + ("" + type.bold) + path.join(' + ').bold;
};

previousTest = function() {
  var fail, num, path, type;
  num = fails.length - 2 - testPosition;
  fail = fails[fails.length - 2 - testPosition];
  if (fail == null) {
    return '';
  }
  type = fail.type === 'test' ? '' : "(" + fail.type + ") ";
  path = fail.node.path;
  return (("" + (pad(2, (num + 1).toString(), '0'))).bold + " FAILED " + ("" + type.bold) + path.join(' + ')).grey;
};

nextTest = function() {
  var fail, num, path, type;
  num = fails.length - testPosition;
  fail = fails[fails.length - testPosition];
  if (fail == null) {
    return '';
  }
  type = fail.type === 'test' ? '' : "(" + fail.type + ") ";
  path = fail.node.path;
  return (("" + (pad(2, (num + 1).toString(), '0'))).bold + " FAILED " + ("" + type.bold) + path.join(' + ')).grey;
};

currentLine = function() {
  var d, data, file, i, j, lines, num, ref1, result;
  num = stepPosition;
  data = stack[num];
  filename = data.getFileName();
  linenumber = parseInt(data.getLineNumber());
  columnnumber = parseInt(data.getColumnNumber());
  if ((filename != null) && (linenumber != null)) {
    try {
      result = EOL;
      d = dirname(filename);
      if (d === '.' && (objective.plugins.dev.nodeSource != null)) {
        if (filename === 'node.js') {
          filename = normalize(objective.plugins.dev.nodeSource + sep + 'src' + sep + filename);
        } else {
          filename = normalize(objective.plugins.dev.nodeSource + sep + 'lib' + sep + filename);
        }
      }
      file = fs.readFileSync(filename);
      if (filename.match(/\.coffee/)) {
        lines = objective.coffee.compile(file.toString(), {
          bare: true
        }).split(EOL);
        lines.unshift('');
      } else {
        lines = file.toString().split(EOL);
      }
      for (i = j = 0, ref1 = lines.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {
        if (!(i + 7 > linenumber)) {
          continue;
        }
        if (!(i - 7 < linenumber)) {
          continue;
        }
        if (linenumber !== i + 1) {
          result += lines[i].grey + EOL;
        }
        if (linenumber === i + 1) {
          result += lines[i].bold + EOL;
        }
      }
    } catch (_error) {}
  }
  return (pad(2, (num + 1).toString(), '0').bold) + " - " + (data.toString()) + "\n" + result;
};

previousLine = function() {
  var data, num;
  num = stepPosition - 1;
  data = stack[num] || '';
  return ("" + (pad(2, (num + 1).toString(), '0'))).bold + " - " + data.toString().grey;
};

nextLines = function() {
  var data, i, j, lines, num, remaining;
  lines = "";
  for (i = j = 1; j <= 5; i = ++j) {
    num = stepPosition + i;
    data = stack[num];
    if (data == null) {
      continue;
    }
    lines += ("" + (pad(2, (num + 1).toString(), '0'))).bold + " - " + data.toString().grey + '\n';
  }
  remaining = stack.length - num - 1;
  if (remaining > 0) {
    lines += ("\n + " + (stack.length - num - 1) + " more").bold;
  }
  return lines;
};

stackReport = function() {
  return (currentLine()) + "\n\n" + (nextLines());
};

render = function(browsing) {
  var afterCount, beforeCount, count, fail, failsText, heading1, heading2, heading3;
  if (browsing == null) {
    browsing = false;
  }
  if (screen == null) {
    return;
  }
  count = fails.length;
  if (count === 0) {
    successCount++;
    content += successCount.toString();
    text.setContent(content);
    screen.render();
    return;
  }
  successCount = 0;
  if (!browsing) {
    content += '|';
  }
  beforeCount = count - testPosition - 1;
  afterCount = testPosition;
  fail = fails[fails.length - 1 - testPosition];
  filename = fail.filename;
  try {
    stack = fail.error.stack;
  } catch (_error) {}
  stack || (stack = []);
  heading1 = ("failed tests (" + count + ")").bold + "  up,down";
  try {
    heading2 = fail.error.toString().red.bold;
  } catch (_error) {}
  heading2 || (heading2 = "");
  heading3 = ("error stack (depth " + stack.length + ")") + "  left,right";
  failsText = filename + "\n" + heading1 + "\n\n" + (previousTest()) + "\n" + (currentTest()) + "\n" + (nextTest()) + "\n\n" + heading2 + "\n" + heading3 + "\n\n" + (stackReport()) + "\n";
  text.setContent(failsText);
  return screen.render();
};

pipeline = objective.pipeline;

pipeline.on('prompt.commands.register.ask', function(command) {
  var bell, close;
  close = void 0;
  bell = function() {};
  return command.create('stacks', {
    description: '(dev) Test failure error stack navigator.',
    keyStrokes: function(ch, key) {
      try {
        if (key.ctrl && (key.name === 'c' || key.name === 'd')) {
          module.exports.disable();
          try {
            blessed.program().clear();
          } catch (_error) {}
          content = '';
          close();
        }
      } catch (_error) {}
      try {
        if (!(fails.length > 0)) {
          return;
        }
      } catch (_error) {
        return;
      }
      if (!fails.length) {
        return;
      }
      try {
        if (key.name === 'return') {
          objective.user.goto({
            type: 'dev.source.file.local',
            filename: filename,
            line: linenumber,
            column: columnnumber
          });
        }
      } catch (_error) {}
      try {
        if (key.name === 'up') {
          testPosition++;
          if (testPosition > fails.length - 1) {
            testPosition = fails.length - 1;
            bell();
            return;
          }
          render(true);
        }
      } catch (_error) {}
      try {
        if (key.name === 'down') {
          testPosition--;
          if (testPosition < 0) {
            testPosition = 0;
            bell();
            return;
          }
          render(true);
        }
      } catch (_error) {}
      try {
        if (key.name === 'left') {
          stepPosition--;
          if (stepPosition < 0) {
            stepPosition = 0;
            bell();
            return;
          }
          render(true);
        }
      } catch (_error) {}
      try {
        if (key.name === 'right') {
          stepPosition++;
          if (stepPosition > stack.length - 1) {
            stepPosition = stack.length - 1;
            bell();
            return;
          }
          return render(true);
        }
      } catch (_error) {}
    },
    run: function(args, callback) {
      module.exports.enable();
      close = callback;
      if (screen == null) {
        screen = blessed.screen({
          autoPadding: true,
          smartCSR: true
        });
      }
      if (text == null) {
        text = blessed.text({
          top: 'top',
          left: 'left',
          content: "Waiting for test."
        });
        screen.append(text);
      }
      try {
        blessed.program().clear();
      } catch (_error) {}
      text.setContent("Waiting for test.");
      return screen.render();
    },
    help: "\nAfter each test run a new batch of failures will appear.\n\nUse 'up' and 'down' arrows to navigate previous and next failure.\n\nUse 'left' and 'right' to step into the stack of the current failure.\n"
  });
});

pipeline.on('dev.test.before.all', function() {
  if (!enabled) {
    return;
  }
  fails = [];
  try {
    text.setContent(content);
    return screen.render();
  } catch (_error) {}
});

pipeline.on('dev.test.after.each', function(arg) {
  var colour, test;
  test = arg.test;
  if (!enabled) {
    return;
  }
  content || (content = '');
  colour = test.error != null ? 'red' : 'green';
  if (test.type === 'test') {
    content += "T"[colour];
  } else if (test.type.match(/beforeAll/)) {
    content += "B"[colour];
  } else if (test.type.match(/beforeEach/)) {
    content += "b"[colour];
  } else if (test.type.match(/afterAll/)) {
    content += "A"[colour];
  } else if (test.type.match(/afterEach/)) {
    content += "a"[colour];
  }
  try {
    text.setContent(content);
    return screen.render();
  } catch (_error) {}
});

pipeline.on('dev.test.after.all', function(arg) {
  var fn, functions;
  functions = arg.functions;
  if (!enabled) {
    return;
  }
  fails = (function() {
    var j, len, results;
    results = [];
    for (j = 0, len = functions.length; j < len; j++) {
      fn = functions[j];
      if (fn.error == null) {
        continue;
      }
      results.push(fn);
    }
    return results;
  })();
  if (fails.length === 0) {
    testPosition = 0;
    stepPosition = 0;
    return render();
  }
  if (testPosition > fails.length - 1) {
    testPosition = 0;
  }
  if (stepPosition > fails[testPosition].error.stack.length - 1) {
    stepPosition = 0;
  }
  return render();
});
